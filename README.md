![image](https://github.com/sgengwbvkvjz/3D-/assets/127504473/183733a5-05b2-4b27-8253-676a41ba0243)代码参考自 https://github.com/kzbkzb/Python-AI 《深度学习100例》/23-day-3D医疗影像识别/深度学习100例-卷积神经网络-3D医疗影像识别 - 第23天.ipynb； 
改写为Pytorch框架下的CT扫描3D图像分类； 
数据集：链接：https://pan.baidu.com/s/1K5pdVp_Q3vsLPTMzVnhJwQ 提取码：3va2；（挺大的没VIP下了2、3个小时）


model.py中
3D卷积和多通道卷积
二维卷积是在单通道的一帧图像上进行滑窗操作，输入是高度H*宽度W的二维矩阵。
三维卷积输入多了深度C这个维度，输入是高度H*宽度W*深度C的三维矩阵。在卷积神经网络中，网络每层的宽度是由每一层特征图图的通道数绝决定的。多通道卷积看起来和三维卷积有一样的深度，但两者之间是有本质的区别的。

卷积核的维度
卷积核的维度指的的进行滑窗操作的维度，而滑窗操作不在channel维度上进行，不管有几个channel，它们都共享同一个滑窗位置（虽然2D多channel卷积的时候每个channel上的卷积核权重是独立的，但滑窗位置是共享的）。所以在讨论卷积核维度的时候，是不把channel维加进去的。
2D conv的卷积核就是(C,H,W)，因此，对于RGB图像做2D卷积，卷积核在输入图像上的的空间维度（即(height,width)两维）上进行进行滑窗操作，卷积核可以是conv2D(3,3) 而不该是conv3D(3,3,3)。
3D conv的卷积核就是(N，C，Depth，H，W)，其中D就是多出来的第三维，根据具体应用，在视频中就是时间维，在CT图像中就是层数维。


3D 卷积神经网络模型（ThreeDCNN），因此模型的输入要求是 3D 图像数据。
具体来说，模型输入的要求为：
数据应该是 3D 图像数据，通常表示为 (depth, height, width)，其中 depth 表示图像的深度或切片数量，height 表示图像的高度，width 表示图像的宽度。
数据应该是张量（tensor）形式，且需要是 PyTorch 支持的张量类型。
输入的图像数据需要进行预处理，如归一化、调整大小等，以满足模型的输入要求。
在此例中，模型的输入通道数（channels）为 1，表示灰度图像，因此每个图像是单通道的。因此，输入张量的形状应该是 (batch_size, 1, depth, height, width)，其中 batch_size 表示每个批次的样本数量。
为了符合模型的输入要求，代码中的数据加载器 MyData 在 __getitem__ 方法中对图像数据进行预处理和调整，并将其转换为 PyTorch 的张量形式。同时，在返回图像数据之前，还通过 img.unsqueeze(0) 方法添加了一个维度，以匹配模型的输入形状。


train.py中
设置设备类型为 'cuda'，表示如果有可用的 CUDA 设备，则使用 CUDA，否则使用 CPU。
实例化自定义的 3D 分类模型 myModel。
打印是否有可用的 CUDA 设备。
如果有可用的 CUDA 设备，则将模型转移到 CUDA 上。
打印训练集中第一个样本的形状。
加载训练集和验证集的 DataLoader，用于批量加载数据。
定义二元交叉熵损失函数。
如果有可用的 CUDA 设备，则将损失函数转移到 CUDA 上。
设置动态学习率的初始学习率、衰减步数、衰减率等参数。
定义优化器，这里使用 Adam 优化器。
构建学习率调度器，采用指数衰减。
设置训练的总轮数 epochs。
定义训练函数 train，用于训练模型。
定义验证函数 validate，用于在每个 epoch 结束后对模型进行验证。
在每个 epoch 中，依次调用训练函数、验证函数，并更新学习率。
最后打印 "Done!" 表示训练结束。

